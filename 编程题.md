## 编程题

---
### 深拷贝
浅拷贝
>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

深拷贝
>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象

**乞丐版**
  
在不使用第三方库的情况下，我们想要深拷贝一个对象，用的最多的就是下面这个方法。

```js
JSON.parse(JSON.stringify());
```

原始数据类型的赋值等于深拷贝，引用类型的赋值为浅拷贝。

**进阶版拷贝**

浅拷贝基础版本代码
```js
function clone(target) {
    let cloneTarget = {};
    for (const key in target) {
        cloneTarget[key] = target[key];
    }
    return cloneTarget;
};
```

由于引用类型也是由原始数据类型组合而成，所以我们自然可以想到利用递归的方式实现深拷贝。
```js
function clone(target) {
    if(typeof target === object) {
        let cloneTarget = {};
        for (const key in target) {
            cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
    } else {
        return target;
    }
    
};
```

这是一个最基础版本的深拷贝，这段代码可以让你向面试官展示你可以用递归解决问题，但是显然，他还有非常多的缺陷，比如，还没有考虑数组。

**考虑数组**

考虑数组我们只需要确定target的类型，来决定将cloneTarget设置为 {} 还是 [].

```js
let cloneTarget = Array.isArray(target) ? [] : {};
```

**循环引用**

若测试用例如下：

```js
const target = {
    field1: 1,
    field2: undefined,
    field3: {
        child: 'child'
    },
    field4: [2, 4, 8]
};
target.target = target;//循环引用
```

用上面的深拷贝会进入死循环，因为存在循环引用，即对象的属性间接或直接的引用了自身的情况。

解决循环引用问题，我们可以额外开辟一个存储空间（map），来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝。

具体流程为

* 检查map中有无克隆过的对象
* 有 -> 直接返回
* 没有 -> 将当前对象作为key，克隆对象作为value进行存储
* 继续克隆
代码如下

```js
const clone = (target, map = new Map()) => {
    if(typeof target === object) {
        let cloneTarget = Array.isAarry(target) ? [] : { } ;
        if(map.get(target)) return;//确认是否赋值过
        else map.set(target, cloneTarget);//保存复制的成员
        for(const key in target ) {
            cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
    } else {
        return target;
    }
}
```

**性能优化**

以上我们就实现了深拷贝的功能，接下来我们就能尝试性能的优化。

WeakMap提代 Map来使代码达到画龙点睛的作用。

```js
function clone(target, map = new WeakMap()) {
    // ...
};
```

WeakMap的作用：
>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。

什么是弱引用呢？
>在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。

在上面的代码中，我们其实只考虑了普通的 object和 array两种数据类型，实际上所有的引用类型远远不止这两个，还有很多，下面我们先尝试获取对象准确的类型。

合理的判断引用类型
首先，判断是否为引用类型，我们还需要考虑 function和 null两种特殊的数据类型：

```js
function isObject(target) {
    const type = typeof target;
    return target !== null && (type === 'object' || type === 'function');
}
复制
if (!isObject(target)) {
        return target;
    }
    // ...
```

---

### trim函数的实现

trim函数：消除字符串两边的空白。

```js
String.prototype.trim = function() {
  return this.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}
```
>正则表达式解析：\s表示空白字符，^\s表示以空白字符开头的字符，\s*表示0个或者若干个\s，\s*$表示以0个或者n个\s结尾。

### instanceof的实现

typeof 和 instanceof的区别

typeof在判断object类型时，只能判断出是否是object，而instanceof能判断出具体是哪一种类型的object。
```js
let s = new String('abc');
typeof s === 'object'// true
s instanceof String // true
```
typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待，因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。

instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可

```js
function new_instance_of(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
    	if (leftVaule === null) {
            return false;	
        }
        if (leftVaule === rightProto) {
            return true;	
        } 
        leftVaule = leftVaule.__proto__ 
    }
}
```

我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。

### 防抖

防抖的目的：处理一些频繁触发的事件。

防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，

**第一版**

根据这段表述，我们可以写第一版的代码：

```js
// 第一版
function debounce(func, wait) {
    var timeout;
    return function () {
        clearTimeout(timeout)
        timeout = setTimeout(func, wait);
    }
}
```

如果我们要使用它，以最一开始的例子为例：
```js
container.onmousemove = debounce(getUserAction, 1000);
```

但是如果使用我们的 debounce 函数，this 就会指向 Window 对象！

所以我们需要将 this 指向正确的对象。

我们修改下代码：
```js
// 第二版
function debounce(func, wait) {
    var timeout;

    return function () {
        var context = this;

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context)
        }, wait);
    }
}
```

JavaScript 在事件处理函数中会提供事件对象 event

但是在我们实现的 debounce 函数中，event为undefind

所以我们再修改一下代码：
```js
// 第三版
function debounce(func, wait) {
    var timeout;

    return function () {
        var context = this;
        var args = arguments;

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context, args)
        }, wait);
    }
}
```

---

### 节流

节流的原理很简单：

如果你持续触发事件，每隔一段时间，只执行一次事件。

根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。
我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。

关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。

**使用时间戳**

让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。

```js
// 第一版
function throttle(func, wait) {
    var context, args;
    var previous = 0;

    return function() {
        var now = +new Date();
        context = this;
        args = arguments;
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
```

上面这个节流函数就能实现第一下立刻触发，往后每wait时间触发一次。但若在等待时间中间停止，最后一次则不会触发。

使用方法
```js
container.onmousemove = throttle(getUserAction, 1000);
```

若想实现前后都触发

```js
const throttle = (func, wait) => {
    let context, args, 
    let previous = 0;

    const later = () => {
        previous = new Date().getTime();
        timeout = null;
        func.apply(context, args);
    }

    const throttled = () => {
        let now = +new Date();
        let remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if(remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            func.apply(context, args);
        } else if (!timeout) {
            timeout = setTimeout(later, remaining);
        }
    }

    return throttled;
}

```