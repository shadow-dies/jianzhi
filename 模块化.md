# 八股

## JS部分

---

### let const 和 var 的区别

* 变量提升：var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。var 声明的变量会被提升到函数作用域的顶部，
* 给全局添加属性：浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。
* 重复声明：var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。
* 初始值设置：在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。
* 指针指向：let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。

var声明的循环变量
在整个循环变量过程中只定义了一个循环变量i，每次循环都对这一个循环变量i进行重复赋值，也就是之后的循环变量数值会覆盖之前的循环变量数值，当循环结束后只有一个循环变量i，存储的是最终的循环变量数值。

let声明的循环变量
在整个循环过程中每次循环都相当于触发执行了一个{   }，每一个{   }对于let定义的变量就是一个独立的作用域，也就是每次循环let声明的循环变量都是一个人独立作用域中的循环变量，每一次循环中循环变量都会存储不同的数据数值，互相之间不会影响，不会覆盖，也就是每次循环let声明的循环变量都相当于是一个独立的变量，不会覆盖之前的数据数值。


### for ... in  和 for... of  的区别

**for...in的特点**

* for … in 循环返回的值都是数据结构的 键值名(即下标)。
* 遍历对象返回的对象的key值,遍历数组返回的数组的下标(key)。
* for … in 循环不仅可以遍历数字键名,还会遍历原型上的值和手动添加的其他键。
* 特别情况下, for … in 循环会以看起来任意的顺序遍历键名
* for… in 的 常规属性和 排序属性：

在ECMAScript规范中定义了 「数字属性应该按照索引值⼤⼩升序排列，字符串属性根据创建时的顺序升序排列。」在这⾥我们把对象中的数字属性称为 「排序属性」，在V8中被称为 elements，字符串属性就被称为 「常规属性」， 在V8中被称为 properties。

也就是说：for...in会先按照排序属性的数字大小从小到大依次遍历，然后再遍历常规属性，常规属性遍历顺序可能不是实际的内部顺序

```js
function Foo() {
 this[99] = 'test-100'
 this[1] = 'test-1'
 this["B"] = 'bar-B'
 this[40] = 'test-50'
 this[9] = 'test-9'
 this[10] = 'test-8'
 this[3] = 'test-3'
 this[8] = 'test-5'
 this["A"] = 'bar-A'
 this["C"] = 'bar-C'
}
var bar = new Foo()
for(key in bar){
 console.log(`index:${key} value:${bar[key]}`)
}
/*输出结果为：
index:1 value:test-1
index:3 value:test-3
index:8 value:test-8
index:9 value:test-9
index:10 value:test-10
index:40 value:test-40
index:99 value:test-99
index:B value:bar-B
index:A value:bar-A
index:C value:bar-C
*/
```

for… in遍历数组的毛病：

1.index索引为字符串型数字，不能直接进行几何运算

2.遍历顺序有可能不是按照实际数组的内部顺序

3.使用for… in会遍历数组/对象所有的可枚举属性，包括原型。

所以for… in更适合遍历对象，不要使用for… in遍历数组。

**for… of 特点**

for… of 循环用来获取一对键值对中的 值,而 for… in 获取的是 键名

一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。

for… of 不同与 forEach, 它可以与 break、continue和return 配合使用,也就是说 for… of 循环可以随时退出循环。

for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串，但是不能遍历对象，因为没有迭代器对象，但如果想遍历对象的属性，你可以用for… in循环（这也是它的本职工作）或搭配内建的Object.keys()方法使用，代码示例：

```js
var obj={
　　a:1,
　　b:2,
　　c:3
}
for (var key of Object.keys(obj)) {
  console.log(key + ": " + obj[key]);
}
//a:1 b:2 c:3
```
for... of遍历类数组对象代码示例：
```js
  // 字符串
  var str = "hello";
  for (let s of str) {
    console.log(s); // h e l l o
  }  
// DOM NodeList对象
  let paras = document.querySelectorAll("p");
  for (let p of paras) {
   p.classList.add("test");
  }  
// arguments对象
  function Args() {
    for (let x of arguments) {
      console.log(x);
    }
  }
Args('a', 'b');// 'a' 'b'
```

### 箭头函数与普通函数的区别

箭头函数没有自己的this
>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。

箭头函数继承来的this指向永远不会改变
>函数中的this就永远指向它定义时所处的全局执行环境中的this

```js
var id = 'GLOBAL';
var obj = {
  id: 'OBJ',
  a: function(){
    console.log(this.id);
  },
  b: () => {
    console.log(this.id);
  }
};
obj.a();    // 'OBJ'
obj.b();    // 'GLOBAL'
new obj.a()  // undefined
new obj.b()  // Uncaught TypeError: obj.b is not a constructor
```

call()、apply()、bind()等方法不能改变箭头函数中this的指向

箭头函数不能作为构造函数使用

### 扩展运算符

对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。

扩展运算符对对象实例的拷贝属于浅拷贝。

扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。

### 对对象与数组的解构的理解

数组的解构

在解构数组时，以元素的位置为匹配条件来提取想要的数据的：
```js
const [a, b, c] = [1, 2, 3]
//a、b、c分别被赋予了数组第0、1、2个索引位的值
```

对象的解构

对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。
```js
const stu = {
  name: 'Bob',
  age: 24
}
const { name, age } = stu
```



---

### null和undefined的区别
undefined和null在if语句中，都会被自动转为false，相等运算符甚至直接报告两者相等。

undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。

null表示"没有对象"，即该处不应该有值。

---

### 原型链继承
类似于C++中的类继承。

引用类型的属性被所有实例共享

``` js
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {}

Child.prototype = new Parent();

var child1 = new Child();

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy", "yayu"]
```

借用构造函数(经典继承)可避免上述的引用类型被共享。
```js
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {
    Parent.call(this);
}

var child1 = new Child();

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy"]
```
组合继承:原型链继承和经典继承双剑合璧。融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。

```js
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {

    Parent.call(this, name);
    
    this.age = age;

}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child1 = new Child('kevin', '18');

child1.colors.push('black');

console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

var child2 = new Child('daisy', '20');

console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]

```
---
### 闭包
闭包 = 函数 + 函数能够访问的自由变量

自由变量
> 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。
>

例题
```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();//输出3
data[1]();//输出3
data[2]();//输出3
```
解析：

当执行到 data[0] 函数之前，此时全局上下文的 VO 为：
```js
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
```
当执行 data[0] 函数的时候，data[0] 函数的作用域链为：
```js
data[0]Context = {
    Scope: [AO, globalContext.VO]
}
```
data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。

所以让我们改成闭包看看：
```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
        return function(){
            console.log(i);
        }
  })(i);
}

data[0]();
data[1]();
data[2]();
```
当执行到 data[0] 函数之前，此时全局上下文的 VO 为：
```js
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
```
跟没改之前一模一样。

当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：
```js
data[0]Context = {
    Scope: [AO, 匿名函数Context.AO globalContext.VO]
}
```
匿名函数执行上下文的AO为：
```js
匿名函数Context = {
    AO: {
        arguments: {
            0: 0,
            length: 1
        },
        i: 0
    }
}
```
data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。

data[1] 和 data[2] 是一样的道理。

---
### 执行环境/执行上下文
在javascript中，执行环境可以抽象的理解为一个object，它由以下几个属性构成：
```
executionContext：{
    variable object：vars,functions,arguments,
    scope chain: variable object + all parents scopes
    thisValue: context object
}
```
在js解释器运行阶段还会维护一个环境栈，当执行流进入一个函数时，函数的环境就会被压入环境栈，当函数执行完后会将其环境弹出，并将控制权返回前一个执行环境。环境栈的顶端始终是当前正在执行的环境。

下面有一道题
```js
比较下面两段代码，试述两段代码的不同之处
// A--------------------------
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();

// B---------------------------
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```
唯一的区别在于环境栈变化不一样，

A: contextStack = [globalContext] ---> contextStack = [checkscopeContext, globalContext] ---> contextStack = [fContext, checkscopeContext, globalContext] ---> contextStack = [checkscopeContext, globalContext] ---> contextStack = [globalContext]

B: contextStack = [globalContext] ---> contextStack = [checkscopeContext, globalContext] ---> contextStack = [fContext, globalContext] ---> contextStack = [globalContext]

javascript是使用静态作用域的语言，他的作用域在函数创建的时候便已经确定

---


### arguments

arguments的东西是个对象，而且是一个特殊的对象，它的属性名是按照传入参数的序列来的，第1个参数的属性名是’0’，第2个参数的属性名是’1’，以此类推，并且它还有length属性，存储的是当前传入函数参数的个数，很多时候我们把这种对象叫做类数组对象。

arguments的一些妙用
1.利用arguments实现方法的重载

下面我们利用arguments对象来实现一个参数相加的函数，不论传入多少参数都行，将传入的参数相加后返回。
```js
function add() {
    var len = arguments.length,
        sum = 0;
    for(;len--;){
        sum += arguments[len];
    }
    return sum;
}

console.log( add(1,2,3) );   //6
console.log( add(1,3) );     //4
console.log( add(1,2,3,5,6,2,7) );   //26
```
由于js是一种弱类型的语言，没有重载机制，当我们重写函数时，会将原来的函数直接覆盖，这里我们能利用arguments，来判断传入的实参类型与数量进行不同的操作，然后返回不同的数值。

---

### this

我们可以简单的理解 this 为调用函数的对象

---

### apply 和 call

这两个函数的作用都是改变函数的上下文

call 的写法
```js
Function.call(obj,[param1[,param2[,…[,paramN]]]])
```

需要注意以下几点：

* 调用 call 的对象，必须是个函数 Function。
* call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。
* 第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。

apply 的写法
```js
Function.apply(obj[,argArray])
```
需要注意的是：

* 它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。
* 第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。

apply 的一些妙用
Math.max。用它来获取数组中最大的一项。
```js
let max = Math.max.apply(null, array);
```
同理，要获取数组中最小的一项，可以这样：
```js
let min = Math.min.apply(null, array);
```

### bind

一句话介绍 bind:
>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )

bind 函数的两个特点：

* 返回一个函数
* 可以传入参数

---

### promise

promise.then 是微任务，它会在所有的宏任务(同步任务)执行完之后才会执行，同时需要promise内部的状态发生变化

```js
const promise = new Promise((resolve, reject) => {
  console.log(1);
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
```

输出结果
```
1 
2 
4
```

---

### new操作符的实现原理

new操作符的执行过程：

（1）首先创建了一个新的空对象

（2）设置原型，将对象的原型设置为函数的 prototype 对象。

（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）

（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

```js
function objectFactory() {
  let newObject = null;
  let constructor = Array.prototype.shift.call(arguments);
  let result = null;
  // 判断参数是否是一个函数
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);
  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);
  // 判断返回对象
  let flag = result && (typeof result === "object" || typeof result === "function");
  // 判断返回结果
  return flag ? result : newObject;
}
// 使用方法
objectFactory(构造函数, 初始化参数);
```

---

### promise.race

Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
```js
const p = Promise.race([p1, p2, p3]);
```
该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行

手动实现：
```js
Promise.race = function (args) {
  return new Promise((resolve, reject) => {
    for (let i = 0, len = args.length; i < len; i++) {
      args[i].then(resolve, reject)
    }
  })
}

```

---

### async

async 函数是什么？一句话，它就是 Generator 函数的语法糖。

async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await

async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。

返回值是 Promise。

async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。

进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。

```js
# async也可以理解为是promimse的语法糖
async function foo() {
    let num = Math.random()
    console.log(num)
    if(num < 0.5){
        return "num < 0.5"
    }else {
        return "num >= 0.5"
    }
}

function goo(){
    return new Promise(resolve => {
        let num = Math.random()
        console.log(num)
        if(num < 0.5){
            resolve("num < 0.5")
        }else {
            resolve("num > 0.5")
        }
    })
}

foo().then((res)=>{
    console.log(res)
})
```
上面代码中，函数foo内部return命令返回的值，会被then方法回调函数接收到。

async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。

如果有多个await命令，可以统一放在try...catch结构中。
```js
async function main() {
  try {
    const val1 = await firstStep();
    const val2 = await secondStep(val1);
    const val3 = await thirdStep(val1, val2);

    console.log('Final: ', val3);
  }
  catch (err) {
    console.error(err);
  }
}
```
---

### 函数柯里化（curry）

函数柯里化（curry）是函数式编程里面的概念。curry的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

简单点来说就是：每次调用函数时，它只接受一部分参数，并返回一个函数，直到传递所有参数为止。

比如**add(1)(2)(3)**

我们可以自己先尝试写一个add(1)(2)(3)
```js
const add = x => y => z => x + y + z;
console.log(add(1)(2)(3));
```

但如果要求支持呢？
```js
add(1, 2, 3);
add(1, 2)(3);
add(1)(2, 3);
```

改进思路是什么呢，要判断当前传入函数的参数个数 (args.length) 是否大于等于原函数所需参数个数 (fn.length) ，如果是，则执行当前函数；如果是小于，则返回一个函数。

```js
const curry = (fn, ...args) => 
    // 函数的参数个数可以直接通过函数数的.length属性来访问
    args.length >= fn.length // 这个判断很关键！！！
    // 传入的参数大于等于原始函数fn的参数个数，则直接执行该函数
    ? fn(...args)
    /**
     * 传入的参数小于原始函数fn的参数个数时
     * 则继续对当前函数进行柯里化，返回一个接受所有参数（当前参数和剩余参数） 的函数
    */
    : (..._args) => curry(fn, ...args, ..._args);

function add1(x, y, z) {
    return x + y + z;
}
const add = curry(add1);
console.log(add(1, 2, 3));
console.log(add(1)(2)(3));
console.log(add(1, 2)(3));
console.log(add(1)(2, 3));
```

Ramda 中的函数所有都支持柯里化。也就是说，所有的多参数函数，默认都可以使用单参数函数。

还是举上面的例子
```js
const addThreeNumbers = (x, y, z) => x + y + z;
const curriedAddaddThreeNumbers = R.curry(addThreeNumbers);
const f = curriedAddaddThreeNumbers(1, 2);
console.log(f(3));
```

**柯里化有什么作用**

主要有3个作用： 参数复用、提前返回和 延迟执行

我们来简单的解释一下: 参数复用：拿上面 f这个函数举例，只要传入一个参数 z，执行，计算结果就是 1 + 2 + z 的结果，1 和 2 这两个参数就直接可以复用了。

提前返回 和 延迟执行 也很好理解，因为每次调用函数时，它只接受一部分参数，并返回一个函数（提前返回），直到(延迟执行)传递所有参数为止。

---

### 前端路由的两种模式：hash模式和 history模式

路由需要实现三个功能：

* 当浏览器地址变化时，切换页面；

* 点击浏览器【后退】、【前进】按钮，网页内容跟随变化；
* 刷新浏览器，网页加载当前路由对应内容；
在单页面web网页中, 单纯的浏览器地址改变, 网页不会重载，如单纯的hash网址改变网页不会变化，因此我们的路由主要是通过监听事件，并利用js实现动态改变网页内容，有两种实现方式：

hash模式：监听浏览器地址hash值变化，执行相应的js切换网页；

history模式：利用history API实现url地址改变，网页内容改变；

它们的区别最明显的就是hash会在浏览器地址后面增加#号，而history可以自定义地址。

使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。下面具体介绍几个使用过程中必须理解的要点：

* hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。如http://localhost/index.html#abc，这里的#abc就是hash；
* 散列值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面；
* 监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置hash值；
* location.hash值的变化会直接反应到浏览器地址栏；

```js
//设置 url 的 hash，会在当前url后加上'#abc'
window.location.hash='abc';
let hash = window.location.hash //'#abc'

window.addEventListener('hashchange',function(){
	//监听hash变化，点击浏览器的前进后退会触发
})


```

history模式概述
* window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。
* History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。
* 由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。
* 浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。

History 对象主要有两个属性。

* History.length：当前窗口访问过的网址数量（包括当前网页）

* History.state：History 堆栈最上层的状态值（详见下文）

---

### jsx

JSX是一种JavaScript的语法扩展，全称JavaScript XML，运用于React架构中，其格式比较像是模版语言，但事实上完全是在JavaScript内部实现的。元素是构成React应用的最小单位，JSX就是用来声明React当中的元素，React使用JSX来描述用户界面，能让我们可以在JS中写html标记语言。

---

### ajax

AJAX 的核心是XMLHttpRequest对象（可在客户端脚本语言（如 javascript）中使用）。 XMLHttpRequest对象用于与后台的服务器交换数据。 所有现代浏览器（IE7+，Firefox，Chrome，Safari 和 Opera）都具有内置的XMLHttpRequest对象。

```js
var xhr =new XHMHttpRequest();
xhr.open('get',url);
xhr.responseType='json';
xhr.onload=function(){
    console.log(xhr.response);
};
xhr.onerror=function(){
    console.log('something wrong')
};
xhr.send();
```

**XMLHttpRequest方法**


**open(method, url, isAsync, userName, password)**

必须通过打开方法初始化XMLHttpRequest对象的 HTTP 和 HTTPS 请求。 此方法指定请求的类型（GET，POST 等），URL，以及是否应异步处理请求。 我将在下一部分中介绍第三个参数。

第四个和第五个参数分别是用户名和密码。 如果服务器需要此参数，则可以提供这些参数或仅提供用户名以进行身份​​验证和授权。

```js
xmlhttp.open("GET","report_data.xml",true);
xmlhttp.open("GET","sensitive_data.xml",false);
xmlhttp.open("POST","saveData",true,"myUserName","somePassord");
```

setRequestHeader(name, value)

成功初始化请求后，可以调用XMLHttpRequest对象的setRequestHeader方法来发送带有请求的 HTTP 标头。

示例：
```js
//Tells server that this call is made for ajax purposes.
xmlhttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest');  
```

**send(payload)**

要发送 HTTP 请求，必须调用XMLHttpRequest的send方法。 此方法接受单个参数，该参数包含要与请求一起发送的内容。
在 POST 请求中，该内容是必需的。 对于 GET 方法，隐式传递null作为参数。

示例：
```js
xmlhttp.send(null); //Request with no data in request body; Mostly used in GET requests.
xmlhttp.send( {"id":"23423"} ); //Request with data in request body; Mostly used in POST/ PUT requests.

```

**abort()**

如果XMLHttpRequest对象的readyState尚未变为 4 （请求完成），则此方法将中止请求。 abort方法确保回调方法不会在异步请求中被调用。

语法：
```js
//Abort the processing
xmlhttp.abort();
```
除上述方法外，onreadystatechange事件监听器非常重要，我们将在下一部分中进行讨论。

**同步和异步 ajax 请求**

XMLHttpRequest对象能够根据网页中的要求发送同步和异步请求。 该行为由打开方法的第三个参数控制。 对于异步请求，此参数设置为true，对于同步请求，此参数设置为false。
```js
xmlhttp.open("GET", "report_data.xml", true); //Asynchrnonos request as third parameter is true
xmlhttp.open("GET", "report_data.xml", false); Synchrnonos request as third parameter is false
```

如果未提供，则此参数的默认值为“true”。

异步 Ajax 请求不会阻止网页，并且在服务器上处理请求时，用户可以继续与页面上的其他元素进行交互。 您应该始终使用异步 Ajax 请求，因为同步 Ajax 请求会使 UI（浏览器）无响应。 这意味着在请求完成之前，用户将无法与网页进行交互。

**onreadystatechange事件**

在上面的示例中，onreadystatechange是向XMLHttpRequest请求注册的事件监听器。 onreadystatechange存储一个函数，该函数将处理从服务器返回的响应。 在请求的生命周期中，所有重要事件都将被调用。 每次在请求处理中完成一个步骤时，readyState的值都会更改并设置为其他值。 让我们看一下可能的值：

0：未初始化请求

1：建立服务器连接

2：接收请求

3：处理请求

4：请求已完成，响应已准备就绪

**处理来自服务器的响应**

要从服务器获取响应，请使用XMLHttpRequest 对象的responseText或responseXML属性。 如果来自服务器的响应是 XML，并且您要将其解析为 XML 对象，请使用responseXML属性。 如果来自服务器的响应不是 XML，请使用responseText属性。

responseText：从服务器获取响应作为字符串

responseXML：从服务器获取 XML 响应

---

### fetch

Fetch完成请求
```js
fetch(url).then(function(response){
    return response.json();
}).then(function(jsonData){
    console.log(jsonData);
}).catch(function(){
    console.log('something wrong');
```

**fetch和ajax的区别**

fetch和XHR都是是获取远端数据的方式，fetch返回的是一个promise对象

fetch是原生js方法，没有使用XMLHttpRequest对象，使用fetch可以不用引用http的类库即可实现。提供了一种简单，合理的方式来跨网络异步获取资源。

（XHR）是一个构造函数，对象用于与服务器交互。通过 XHR可以在不刷新页面的情况下请求特定 URL。即允许网页在不影响用户操作的情况下，更新页面的局部内容。可以用于获取任何类型的数据。

当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject，即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve（如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 ok 属性为 false），仅当网络故障时或请求被阻止时，才会标记为 reject。

fetch 不会发送跨域 cookie，除非你使用了 credentials 的初始化选项。（自 2018 年 8 月以后，默认的 credentials 政策变更为 same-origin。Firefox 也在 61.0b13 版本中进行了修改）

---

## CSS
---

### 内联元素

内联元素一般是内容的容器，一般情况下，内联元素只能包含内容或者其它内联元素，宽度和长度依据内容而定，不可以设置，可以和其它元素和平共处于一行。内联元素适合显示具体内容。

特点：

1、和其他元素都在一行上；

2、高度、行高和顶以及底边距都不可改变；

3、宽度就是它的文字或图片的宽度，不可改变。

常用的内联(行内)元素：

* a - 锚点

* abbr - 缩写

* acronym - 首字

* b - 粗体(不推荐)

* bdo - bidi override

* big - 大字体

* br - 换行

* cite - 引用

* code - 计算机代码(在引用源码的时候需要)

* dfn - 定义字段

* em - 强调

* font - 字体设定(不推荐)

* i - 斜体

* img - 图片

* input - 输入框

* kbd - 定义键盘文本

* label - 表格标签

* q - 短引用

* s - 中划线(不推荐)

* samp - 定义范例计算机代码

* select - 项目选择

* small - 小字体文本

* span - 常用内联容器，定义文本内区块

* strike - 中划线

* strong - 粗体强调

* sub - 下标

* sup - 上标

* textarea - 多行文本输入框

* tt - 电传文本

* u - 下划线

* var - 定义变量

---

### CSS优先级

在css样式表中，同一个CSS样式你写了两次，后面的会覆盖前面的，在开发中基本不会使用。

不同的权重，权重值高则生效
>权重记忆口诀：从0开始，一个行内样式+1000，一个id选择器+100，一个属性选择器、class或者伪类+10，一个元素选择器，或者伪元素+1，通配符+0。

**!important(提升样式优先级)**

!important的作用是提升样式优先级，如果加了这句的样式的优先级是最高的。不过我这里建议大家一下，!important最好不要使用。当两个样式都使用!important时，权重值大的优先级更高

---

默认情况下，块级元素的内容宽度是其父元素的宽度的 100％，并且与其内容一样高。内联元素高宽与他们的内容高宽一样。你不能对内联元素设置宽度或高度——它们只是位于块级元素的内容中。如果要以这种方式控制内联元素的大小，则需要将其设置为类似块级元素 display: block;。

### position

如果所有的父元素都没有显式地定义 position 属性，那么所有的父元素默认情况下 position 属性都是 static。

**static**
>静态定位是每个元素获取的默认值——它只是意味着“将元素放入它在文档布局流中的正常位置 ——这里没有什么特别的。

**relative**
>它与静态定位非常相似，占据在正常的文档流中，除了你仍然可以修改它的最终位置，包括让它与页面上的其他元素重叠。

**absulute**
>绝对定位的元素不再存在于正常文档布局流中。相反，它坐在它自己的层独立于一切。绝对定位将元素固定在相对于其位置最近的祖先。（如果没有，则为初始包含它的块）

**fixed**
>与绝对定位的工作方式完全相同，只有一个主要区别：绝对定位将元素固定在相对于其位置最近的祖先。（如果没有，则为初始包含它的块）而固定定位固定元素则是相对于浏览器视口本身。

**sticky**
>它基本上是相对位置和固定位置的混合体，它允许被定位的元素表现得像相对定位一样，直到它滚动到某个阈值点（例如，从视口顶部起 10 像素）为止，此后它就变得固定了。

### display

none
>元素不显示，并且会从文档流中移除。

block
>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。

inline
>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。

inline-block
>默认宽度为内容宽度，可以设置宽高，同行显示。

list-item
>像块类型元素一样显示，并添加样式列表标记。

table
>此元素会作为块级表格来显示。

inherit
>规定应该从父元素继承display属性的值。



---

### CSS3新特性

**过渡**

语法：

transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)
```css
/*宽度从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒，0.2秒后执行过渡*/
transition：width,.5s,ease,.2s
```
**动画**

语法：

animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）
```css
/*2秒后开始执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/
animation: logo2-line 2s linear 2s;
```

**形状转换**

transform:适用于2D或3D转换的元素
transform-origin：转换元素的位置（围绕那个点进行转换）。默认(x,y,z)：(50%,50%,0)

**选择器**

**阴影**

box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认是从里往外，设置inset就是从外往里）;

**边框图片**

border-image: 图片url 图像边界向内偏移 图像边界的宽度(默认为边框的宽度) 用于指定在边框外部绘制偏移的量（默认0） 铺满方式--重复（repeat）、拉伸（stretch）或铺满（round）（默认：拉伸（stretch））;

```css
.demo {
    border: 15px solid transparent;
    padding: 15px;   
    border-image: url(border.png);
    border-image-slice: 30;
    border-image-repeat: round;
    border-image-outset: 0;
}
```

**边框圆角**

```css
border-radius: n1,n2,n3,n4;
border-radius: n1,n2,n3,n4/n1,n2,n3,n4;
/*n1-n4四个值的顺序是：左上角，右上角，右下角，左下角。*/
```

**反射**

这个也可以说是倒影

-webkit-box-reflect:方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片

**超出省略号**

```css
text-overflow:ellipsis;
```

**文字阴影**

语法：text-shadow:水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。
```css
text-shadow: 0 0 10px #f00;
```

**渐变 Gradient**

CSS3 Gradient分为linear-gradient(线性渐变)和radial-gradient(径向渐变)。简单来讲就是一种是直线渐变，一种是圆心向外的渐变。

语法：
```css
linear-gradient( top/left, start_color, end_color )
```


**Filter（滤镜）**




**颜色**

这个其实就是css3提供了新的颜色表示方法。

rgba
>（rgb为颜色值，a为透明度）

**flex**

**grid**

**盒子模型**


---

### flex(弹性布局/弹性盒子)

flexbox 是一种一维的布局，是因为一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。主要用于实现响应式布局.

**主轴**

主轴由 flex-direction 定义，可以取 4 个值：
```
row
row-reverse
column
column-reverse
```
如果你选择了 row 或者 row-reverse，你的主轴将沿着 inline 方向延伸。

选择 column 或者 column-reverse 时，你的主轴会沿着上下方向延伸 — 也就是 block 排列的方向。

**Flex 容器**

文档中采用了 flexbox 的区域就叫做 flex 容器。为了创建 flex 容器，我们把一个容器的 display 属性值改为 flex 或者 inline-flex。完成这一步之后，容器中的直系子元素就会变为 flex 元素。所有 CSS 属性都会有一个初始值，所以 flex 容器中的所有 flex 元素都会有下列行为：

* 元素排列为一行 (flex-direction 属性的初始值是 row)。
* 元素从主轴的起始线开始。
* 元素不会在主维度方向拉伸，但是可以缩小。
* 元素被拉伸来填充交叉轴大小。
* flex-basis 属性为 auto。
* flex-wrap 属性为 nowrap。

**用 flex-wrap 实现多行 Flex 容器**

属性flex-wrap添加一个属性值wrap。如果您的项目太大而无法全部显示在一行中，则会换行显示。

**简写属性 flex-flow**

你可以将两个属性 flex-direction 和 flex-wrap 组合为简写属性 flex-flow。第一个指定的值为 flex-direction ，第二个指定的值为 flex-wrap.

```css
.box {
        display: flex;
        flex-flow: row wrap;
      }

      
```

**Flex 元素属性：flex-grow**

flex-grow 若被赋值为一个正整数，flex 元素会以 flex-basis 为基础，沿主轴方向增长尺寸。这会使该元素延展，并占据此方向轴上的可用空间（available space）。如果有其他元素也被允许延展，那么他们会各自占据可用空间的一部分。

如果我们给上例中的所有元素设定 flex-grow 值为 1，容器中的可用空间会被这些元素平分。它们会延展以填满容器主轴方向上的空间。

**Flex 属性的简写**

你可能很少看到 flex-grow，flex-shrink，和 flex-basis 属性单独使用，而是混合着写在 flex 简写形式中。 Flex 简写形式允许你把三个数值按这个顺序书写 — flex-grow，flex-shrink，flex-basis。

```css
 .box {
        display: flex;
      }

.one {
    flex: 1 1 auto;
    }
```

---


## 计算机网络部分

### https
HTTPS是 HTTP Secure 或 HTTP over SSL。

SSL（Security Socket Layer）该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。

---

### websocket协议
基于TCP的应用协议

与http的区别在于建立连接后客户端与服务端的连接时持续的，随时可以互相发送信息。建立连接前的握手使用http协议，握手成功后，通信不再使用HTTP协议，而采用WebSocket独立的数据帧。

---

### TCP
连接三次握手：
>初始化Sequence Number 的值，需要互相通知对方初始化的值并给与对方回应。

超时重传
>发送方等待目标ack超时时启动。

快速重传
>发送方收到三个重复ack时启动

---

### UDP
传输层协议，最大的特点是无需连接吗，不提供可靠传输的服务，对应用层交下来的报文，添加首部后直接乡下交付为IP层

---

## html
### 事件冒泡
众所周知，html里元素触发的事件是往父元素不断冒泡的，如触发了子元素的onclick，会一层层往父元素冒泡，触发父元素的onclick

若想组织冒泡：

```js
onClick={e => e.stopPropagation()}
```

---

## React

### hook （钩子函数）

什么是Hooks?

首先：React的组件创建方式，一种是类组件，一种是纯函数组件。

React团队认为组件的最佳写法应该是函数，而不是类。

但是纯函数组件有着类组件不具备的特点：

* 纯函数组件没有状态
* 纯函数组件没有生命周期
* 纯函数组件没有this
这就注定，纯函数组件只能做UI展示的功能，如果涉及到状态的管理与切换，我们就必须得用类组件或者redux，但是在简单的页面中使用类组件或者redux会使代码显得很重。

因此，React团队设计了React hooks（钩子）。

React Hooks的意思是：组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码“钩”进来。

四种常用的钩子：
```js
useState()
useReducer()
useContext()
useEffect()
useRef()
```

**UseState()**

我们知道，纯函数组件没有状态，useState()用于为函数组件引入状态。

**useReducer()**

useState() 的替代方案，用于包含多种状态，或者下一个 state 依赖于之前的 state，实现函数组件的状态管理。

基本原理是通过用户在页面中发起action, 从而通过reducer方法来改变state, 从而实现页面和状态的通信。

点击加1，点击减1
```js
//实现点击改变状态
import React,{useReducer} from 'react'
import './App.css';
function App(){
  
  //useReducer(),state表示状态，action表示相关操作
  const reducer = (state,action)=>{
    if (action.type === 'add') {
      return {
          ...state,
          count: state.count + 1,
      }
    }else if (action.type === 'jian') {
      return {
          ...state,
          count: state.count - 1,
      }
    } else {
      return state
    } 
  }
 
  const addCount=()=>{
    dispatch({
      type:'add'
    })
  }
  const min=()=>{
    dispatch({
      type:'jian'
    })
  }
  const [state,dispatch] = useReducer(reducer,{count:0})
  return(
    <div>
      <div>{state.count}</div>
      <button onClick={addCount}>点击加1</button>
      <button onClick={min}>点击减1</button>
    </div>
  )
}
export default App;
```

**useContext()**

useContext()用于在组件之间共享状态，而不必显式地通过组件树的逐层传递 props。

实现步骤：

1.使用createContext创建Context对象

2.在顶层组件通过provider提供数据

3.在底层组件通过useContext函数获取数据
```js
//引入状态钩子useState()
import React,{useContext} from 'react'
import './App.css';
function App(){
    //通过createContext来创建上下文
    const AppContext = React.createContext()

    const Achild = ()=>{
        //在子组件中通过useContext来获取数据
        const {name1} = useContext(AppContext)
        return(
            <div>
                这是组件A,使用的name值是:{name1}
            </div>
        )
    }
    
    const Bchild = ()=>{
        //在子组件中通过useContext（Context句柄）来获取数据
        const {name2} = useContext(AppContext)
        return(
            <div>
                这是组件B,使用的name值是:{name2}
            </div>
        )
    }
    return (
            //AppContext.Provider数据共享组件,来确定共享范围,通过value来分发内容
          <AppContext.Provider value={{name1:'jack',name2:'Bob'}}>
              <Achild></Achild>
              <Bchild></Bchild>
          </AppContext.Provider>
        );
}
export default App;
```

**useEffect()**

useEffect()可以检测数据更新 。，可以用来更好的处理副作用，比如异步请求等。

useEffect()接受两个参数，第一个参数是你要进行的异步操作，第二个参数是一个数组，用来给出Effect()的依赖项。

只要数组发生改变，useEffect()就会执行。

当第二项省略不填时，useEffect()会在每次组件渲染时执行，这一点类似于componentDidMount。

>useEffect回调在dom渲染完毕之后执行 和vue里边的Watch效果比较像，但是执行时机是不同的 watch一开始就执行了

举例：

第二个参数省略时：
```js
import React,{useState,useEffect} from 'react'
import './App.css';
function App(){
  const [loading,setLoading] = useState(true)
  //相当于componentDidMount
  //useEffect()第二个参数未填
  useEffect(()=>{
    setTimeout(()=>{
      setLoading(false)
    },3000)
  })
  //loadling为true时显示Loading... 3秒后loading变成了false,显示内容加载完毕
  return (
    loading?<div>Loading</div>:<div>内容加载完毕</div>
  )
}
export default App;
```
useEffect()返回一个函数：

当useEffect()返回一个函数时，该函数会在组件卸载时执行。

举例：

当点击switch时，组件被卸载，定时器被清除，控制台不再打印。
```js
import React,{useEffect,useState} from 'react'
import './App.css';

function Test (){
  useEffect(()=>{
    let timer = setInterval(()=>{
      console.log('定时器正在执行')
    },1000)
    return ()=>{
      //清除定时器
      clearInterval(timer)
    }
  },[])
  return(
    <div>this is test</div>
  )
}

function App(){
  const [flag,setFlag] = useState(true)
  return (
    <div>
      {flag?<Test/>:null}
      <button onClick={()=>{setFlag(false)}}>switch</button>
    </div>
  )
}

export default App;
```

**useRef()**

用于在函数组件中获取真实的DOM元素对象或者是组件实例。（因为函数组件没有实例，所以这里的获取组件实例指的是获取类组件实例）

使用步骤：

1.导入useRef()函数

2.执行useRef()函数并传入null，返回值为一个对象，内部有一个current属性存放拿到的dom对象（组件实例）

3.通过ref绑定要获取的元素或者组件实例。

举例：

获取dom和组件实例，可以看到结果在控制台打印了出来
```js
import React,{useEffect, useRef} from 'react'
import './App.css';

//组件实例 类组件（函数组件没有实例）
//dom对象 标签

class Test extends React.Component{
  render(){
    return (
      <div>我是类组件</div>
    )
  }
}

function App(){
  const testRef = useRef(null)
  const h1Ref = useRef(null)
  //useEffect回调在dom渲染完毕之后执行
  //和vue里边的Watch效果比较像，但是执行时机是不同的 watch一开始就执行了
  useEffect(()=>{
    console.log(testRef.current)
    console.log(h1Ref.current)
  },[])
  return(
    <div>
      {/* 获取类组件实例 */}
      <Test ref={testRef}/>
      {/* 获取DOM对象 */}
      <h1 ref={h1Ref}>this is h1</h1>
    </div>
  )
}
export default App;
```

**自定义钩子函数**

根据自己的业务需求，自行封装一个钩子函数以供自己使用。

举例：自定义一个获取表单数据的钩子函数
```js
import React,{useState} from 'react'
import './App.css';


// 自定义hook(use开头)
// 重用受控表单创建state和onChange方法逻辑
/**
 * 
 * @param {string | number} initialValue 初始默认值
 * @returns 
 */
//获取表单数据
const useInput = (initialValue) => {
  const [value, setValue] = useState(initialValue)

  return {
    value,
    onChange: e => setValue(e.target.value)
  }
}

// 表单组件
const  App = () => {

  const username = useInput('admin')

  const password = useInput('')

  const onSubmit = (e) => {
    //阻止默认事件发生
    e.preventDefault()
    // 获取表单值
    console.log(username.value, password.value);
  }

  return (
    <form onSubmit={onSubmit} >
      <input type="text" {...username} />
      <input type="password" {...password} />
      <button type="submit">提交</button>
    </form>
  );
}
export default App;
```

**React Hooks中可以对性能进行优化的函数**

**useMemo()**

具有缓存作用，有助于避免在每次渲染时都进行高开销的计算。

用于优化代码

当组件发生更新时，组件一定会被重新渲染，并且担当引入子组件时，子组件不发生变化也会重新渲染组件，因此会造成性能的浪费，于是引入了memo插件

memo包裹组件并返回包装后的组件，子组件内部数据没有改变就不会进行渲染

```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```
把创建函数和依赖项数组作为参数传入useMemo，当某个依赖改变时才会重新执行useMemo()函数。

如果没有提供依赖项数组，useMemo()每次渲染时都会重新执行useMemo()函数。

举例：
useMemo()监听count的值，当count的值改变时，newValue会更新。
```js
import { useState, useMemo} from 'react';

export default () => {
    const  [count, setCount] = useState(0)
    const [num, setNum] = useState(0)
    const newValue = useMemo(()=>{
        console.log(`count 值为${count}`)
        console.log(`num 值为 ${num}`)
        return count+num
    },[count])
    return(
        <div>
            <h1>{count}</h1> 
            <button onClick={()=>{setCount(count+1)}}>count + 1</button>
            <hr/>
            <h1>{num}</h1> 
            <button onClick={()=>{setNum(num+1)}}>Num + 1</button>
            <hr/>
            <h2>{newValue}</h2>
        </div>
    )
}
```
点击5次num+1，num变为5，虽然newValue仍然为0，但是num=5已经被缓存了；点击count+1，他会计算count此时的值1与num缓存的值5的和，最终结果newValue为6。

**useCallback()**

useCallback 可以说是 useMemo 的语法糖，能用 useCallback 实现的，都可以使用 useMemo, 常用于react的性能优化

与useMemo()一样，依赖数组改变时才会重新执行useCallback()函数。

如果没有依赖数组，每次渲染都会重新执行useCallback()函数。
```js
const memoizedCallback = useCallback(() => {doSomething(a, b)},[a, b]);
```
举例：

和上述useMemo()的效果一样，区别是useCallback()调用newValue时是：newValue()
```js
import React,{ useState, useCallback} from 'react';

function App(){
  const  [count, setCount] = useState(0)
    const [num, setNum] = useState(0)
    const newValue = useCallback(()=>{
        console.log(`count 值为${count}`)
        console.log(`num 值为 ${num}`)
        return count+num;
    },[count])
    
    return(
        <div>
            <h1>{count}</h1> 
            <button onClick={()=>{setCount(count+1)}}>count + 1</button>
            <hr/>
            <h1>{num}</h1> 
            <button onClick={()=>{setNum(num+1)}}>Num + 1</button>
            <hr/>
            {/* 调用useCallback 返回的值 */}
            <h2>{newValue()}</h2>
        </div>
    )
}
export default App;
```

**useMemo()和useCallback()的区别**
```
useMemo()返回缓存的变量（memoized)

useCallback()返回缓存的函数
```
### 生命周期

react有三个生命周期

挂载
>组件实例被创建并插入DOM

更新
>prop或者state有更新

更新需要所有组件didmount后才能进入，更新状态的生命周期

卸载
>组件实例被卸载

---
### 合成事件

原生事件: 在 componentDidMount生命周期里边进行addEventListener绑定的事件

合成事件: 通过 JSX 方式绑定的事件，比如 onClick={() => this.handle()}

在 React 17 中，React 将不再向 document 附加事件处理器。而会将事件处理器附加到渲染 React 树的根 DOM 容器中

---


### useEffect

useEffect使用时有以下4种情况:

**1、不传递**

useEffect不传递第二个参数会导致每次渲染都会运行useEffect。然后，当它运行时，它获取数据并更新状态。然后，一旦状态更新，组件将重新呈现，这将再次触发useEffect，这就是问题所在。
```js
useEffect(()=>{undefined
console.log(props.number)
setNumber(props.number)
}) //所有更新都执行
```
**2、传递空数组**
```js
useEffect(()=>{undefined
console.log(props)
},[]) //仅在挂载和卸载的时候执行
```
**3、传递一个值**
```js
useEffect(()=>{undefined
console.log(count)
},[count]) //count更新时执行
```
**4、传递多个**
```js
const Asynchronous : React.FC=({number})=>{undefined
const [number2,setNumber2] = useState(number);
useEffect(()=>{undefined
console.log(number)
setNumber2(number)
},[number,setNumber2]) //监听props对象number的更改
//setNumber2是useState返回的setter，所以不会在每次渲染时重新创建它，因此effect只会运行一次
}
```

**5、return 方法**
```js
const timer = setInterval(() => {undefined
setCount(count + 1)
}, 1000)
// useEffect方法的第一个参数是一个函数，函数可以return一个方法，这个方法就是在组件销毁的时候会被调用
useEffect(() => {undefined
return () => {undefined
clearInterval(timer)
}
}, [])
```
---

### setState
* 1.调用setState不会立即更新
* 2.所有组件使用的是同一套更新机制，当所有组件didmount后，父组件didmount，然后执行更新
* 3.更新时会把每个组件的更新合并，每个组件只会触发一次更新的生命周期。

异步函数和原生事件中的setstate,在setTimeout中调用setState,同步更新.

执行流程
>* 1.将setState传入的partialState参数存储在当前组件实例的state暂存队列中。
>* 2.判断当前React是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。
>* 3.如果未处于批量更新状态，将批量更新状态标识设置为true，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。
>* 4.调用事务的waper方法，遍历待更新组件队列依次执行更新。
>* 5.执行生命周期componentWillReceiveProps。
>* 6.将组件的state暂存队列中的state进行合并，获得最终要更新的state对象，并将队列置为空。
>* 7.执行生命周期componentShouldUpdate，根据返回值判断是否要继续更新。
>* 8.执行生命周期componentWillUpdate。
>* 9.执行真正的更新，render。
>* 10.执行生命周期componentDidUpdate。

### diff算法

---

### virtural dom



优点
* 处理了浏览器的兼容，避免用户直接操作真实DOM

* 内容经过了XSS处理，可以防范XSS攻击

* 更容易实现跨平台

* 差异化更新，减少Dom更新次数

缺点

* 虚拟Dom挂载在内存中，消耗了额外内存

* 有时候不一定快（首次渲染）

---

### refs

官方文档对Refs的描述是：
>Refs提供了一种方式，允许我们访问DOM节点或在render方法中创建的React元素。

**何时使用Refs**

1、管理焦点，文本选择或媒体播放。

2、触发强制动画。

3、集成第三方DOM库。

也就是说，在React无法控制局面的时候就需要直接操作Refs了。


**Refs有哪些使用方式**

1、字符串形式的refs。（可能在以后的版本中弃用）

2、回调形式的refs。

3、使用React.createRef()创建，并通过ref属性附加到React元素。

字符串形式的refs

字符串形式的ref 存在效率问题，不太推荐使用，可能在未来的版本中移除。

写个简单例子，点击按钮打印input中输入的值。

```js
class Demo extends Component{
    constructor(props){
        super(props)
    }
    showData=()=>{
       console.log(this.refs.input1)//拿到标签为input1的真实DOM
       console.log(this.refs.input1.value)
    }
    render(){
        return(
            <div>
                <input ref='input1' type="text" placeholder='点击按钮提示数据'/>&nbsp;
                <button onClick={this.showData}>点我提示左侧数据</button>
            </div>
        )
    }
}
```

回调形式的refs

React 也支持另一种设置 refs 的方式，也就是回调形式的refs。它能使我们更加容易并且精细的控制refs的设置和解除。

在ref中，你会传递一个函数。这个函数中接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问。

写个简单例子，同样是点击按钮打印input中输入的值。

```js
class Demo extends Component{
    constructor(props){
        super(props)
    }
    showData=()=>{
       console.log(this.input1)//ref中的回调函数将自身节点放在了组件节点自身上，取名为input1
       console.log(this.input1.value)
    }
    render(){
        return(
            <div>
                <input ref={(currentNode)=>{this.input1=currentNode}} type="text" placeholder='点击按钮提示数据'></input>&nbsp;
                <button onClick={this.showData}>点我提示左侧数据</button>
            </div>
        )
    }
}
```

createRef的使用

createRef 是 **React v16.3 ** 新增的API，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。

Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。

Refs 通常在 React 组件的构造函数中定义，或者作为函数组件顶层的变量定义，然后附加到 render() 函数中的元素。

同样是点击按钮打印input中输入值的例子。
```js
class Demo extends Component{
    constructor(props){
        super(props)
        // React.creatRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点
        this.myRef=React.createRef()
    }
    showData=()=>{
       console.log(this.myRef)//输出myRef容器
       console.log(this.myRef.current)//输出input节点
       console.log(this.myRef.current.value)//输出input中的值
    }
    render(){ 
        return(
            <div>
                <input ref={this.myRef} type="text" placeholder='点击按钮提示数据'></input>&nbsp;
                <button onClick={this.showData}>点我提示左侧数据</button>
            </div>
        )
    }
```

---

----
## 编程题

---
### 深拷贝
浅拷贝
>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

深拷贝
>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象

**乞丐版**
  
在不使用第三方库的情况下，我们想要深拷贝一个对象，用的最多的就是下面这个方法。

```js
JSON.parse(JSON.stringify());
```

原始数据类型的赋值等于深拷贝，引用类型的赋值为浅拷贝。

**进阶版拷贝**

浅拷贝基础版本代码
```js
function clone(target) {
    let cloneTarget = {};
    for (const key in target) {
        cloneTarget[key] = target[key];
    }
    return cloneTarget;
};
```

由于引用类型也是由原始数据类型组合而成，所以我们自然可以想到利用递归的方式实现深拷贝。
```js
function clone(target) {
    if(typeof target === object) {
        let cloneTarget = {};
        for (const key in target) {
            cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
    } else {
        return target;
    }
    
};
```

这是一个最基础版本的深拷贝，这段代码可以让你向面试官展示你可以用递归解决问题，但是显然，他还有非常多的缺陷，比如，还没有考虑数组。

**考虑数组**

考虑数组我们只需要确定target的类型，来决定将cloneTarget设置为 {} 还是 [].

```js
let cloneTarget = Array.isArray(target) ? [] : {};
```

**循环引用**

若测试用例如下：

```js
const target = {
    field1: 1,
    field2: undefined,
    field3: {
        child: 'child'
    },
    field4: [2, 4, 8]
};
target.target = target;//循环引用
```

用上面的深拷贝会进入死循环，因为存在循环引用，即对象的属性间接或直接的引用了自身的情况。

解决循环引用问题，我们可以额外开辟一个存储空间（map），来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝。

具体流程为

* 检查map中有无克隆过的对象
* 有 -> 直接返回
* 没有 -> 将当前对象作为key，克隆对象作为value进行存储
* 继续克隆
代码如下

```js
const clone = (target, map = new Map()) => {
    if(typeof target === object) {
        let cloneTarget = Array.isAarry(target) ? [] : { } ;
        if(map.get(target)) return;//确认是否赋值过
        else map.set(target, cloneTarget);//保存复制的成员
        for(const key in target ) {
            cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
    } else {
        return target;
    }
}
```

**性能优化**

以上我们就实现了深拷贝的功能，接下来我们就能尝试性能的优化。

WeakMap提代 Map来使代码达到画龙点睛的作用。

```js
function clone(target, map = new WeakMap()) {
    // ...
};
```

WeakMap的作用：
>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。

什么是弱引用呢？
>在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。

在上面的代码中，我们其实只考虑了普通的 object和 array两种数据类型，实际上所有的引用类型远远不止这两个，还有很多，下面我们先尝试获取对象准确的类型。

合理的判断引用类型
首先，判断是否为引用类型，我们还需要考虑 function和 null两种特殊的数据类型：

```js
function isObject(target) {
    const type = typeof target;
    return target !== null && (type === 'object' || type === 'function');
}
复制
if (!isObject(target)) {
        return target;
    }
    // ...
```

---

### trim函数的实现

trim函数：消除字符串两边的空白。

```js
String.prototype.trim = function() {
  return this.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}
```
>正则表达式解析：\s表示空白字符，^\s表示以空白字符开头的字符，\s*表示0个或者若干个\s，\s*$表示以0个或者n个\s结尾。

### instanceof的实现

typeof 和 instanceof的区别

typeof在判断object类型时，只能判断出是否是object，而instanceof能判断出具体是哪一种类型的object。
```js
let s = new String('abc');
typeof s === 'object'// true
s instanceof String // true
```
typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待，因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。

instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可

```js
function new_instance_of(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
    	if (leftVaule === null) {
            return false;	
        }
        if (leftVaule === rightProto) {
            return true;	
        } 
        leftVaule = leftVaule.__proto__ 
    }
}
```

我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。

### 防抖

防抖的目的：处理一些频繁触发的事件。

防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，

**第一版**

根据这段表述，我们可以写第一版的代码：

```js
// 第一版
function debounce(func, wait) {
    var timeout;
    return function () {
        clearTimeout(timeout)
        timeout = setTimeout(func, wait);
    }
}
```

如果我们要使用它，以最一开始的例子为例：
```js
container.onmousemove = debounce(getUserAction, 1000);
```

但是如果使用我们的 debounce 函数，this 就会指向 Window 对象！

所以我们需要将 this 指向正确的对象。

我们修改下代码：
```js
// 第二版
function debounce(func, wait) {
    var timeout;

    return function () {
        var context = this;

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context)
        }, wait);
    }
}
```

JavaScript 在事件处理函数中会提供事件对象 event

但是在我们实现的 debounce 函数中，event为undefind

所以我们再修改一下代码：
```js
// 第三版
function debounce(func, wait) {
    var timeout;

    return function () {
        var context = this;
        var args = arguments;

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context, args)
        }, wait);
    }
}
```

---

### 节流

节流的原理很简单：

如果你持续触发事件，每隔一段时间，只执行一次事件。

根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。
我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。

关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。

**使用时间戳**

让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。

```js
// 第一版
function throttle(func, wait) {
    var context, args;
    var previous = 0;

    return function() {
        var now = +new Date();
        context = this;
        args = arguments;
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
```

上面这个节流函数就能实现第一下立刻触发，往后每wait时间触发一次。但若在等待时间中间停止，最后一次则不会触发。

使用方法
```js
container.onmousemove = throttle(getUserAction, 1000);
```

若想实现前后都触发

```js
const throttle = (func, wait) => {
    let context, args, 
    let previous = 0;

    const later = () => {
        previous = new Date().getTime();
        timeout = null;
        func.apply(context, args);
    }

    const throttled = () => {
        let now = +new Date();
        let remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if(remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            func.apply(context, args);
        } else if (!timeout) {
            timeout = setTimeout(later, remaining);
        }
    }

    return throttled;
}

```

## 模块化

### 模块化的理解

什么是模块?
* 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起
* 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信

### ES6 模块与 CommonJS 模块的差异

① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。

ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

---

### webpack

配置文件分析
```js
var path = require('path');
var node_modules = path.resolve(__dirname, 'node_modules');
var pathToReact = path.resolve(node_modules, 'react/dist/react.min.js');

module.exports = {
  // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。
  entry: {
    bundle: [
      'webpack/hot/dev-server',
      'webpack-dev-server/client?http://localhost:8080',
      path.resolve(__dirname, 'app/app.js')
    ]
  },
  // 文件路径指向(可加快打包过程)。
  resolve: {
    alias: {
      'react': pathToReact
    }
  },
  // 生成文件，是模块构建的终点，包括输出文件与输出路径。
  output: {
    path: path.resolve(__dirname, 'build'),
    filename: '[name].js'
  },
  // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。
  module: {
    loaders: [
      {
        test: /\.js$/,
        loader: 'babel',
        query: {
          presets: ['es2015', 'react']
        }
      }
    ],
    noParse: [pathToReact]
  },
  // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ]
};
```

bundle，chunk，module是什么？


● bundle：是由webpack打包出来的⽂件； 

● chunk：代码块，⼀个chunk由多个模块组合⽽成，⽤于代码的合并和分割；

● module：是开发中的单个模块，在webpack的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack会从配置的 entry中递归开始找出所有依赖的模块。

### webpack打包

webpack是一种前端资源构建工具，一个静态模块打包器。目的是把有依赖关系的各种文件打包成一系列的静态资源。

1.初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；

2.开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；

3.确定入口：根据配置中的 entry 找出所有的入口文件；

4.编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；

5.完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；

6.输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；

7.输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

打包后的⽂件实际上就是⼀个⽴即执⾏函数，这个⽴即执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。

功能：

1.用来在工程化开发中上线打包,

2.用来压缩混淆;

3.用来图片转base64,

4.可以有效的提高浏览器的性能

**有哪些常见的Loader？他们是解决什么问题的？**

file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件

url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去

source-map-loader：加载额外的 Source Map 文件，以方便断点调试

image-loader：加载并且压缩图片文件

babel-loader：把 ES6 转换成 ES5

css-loader：加载 CSS，支持模块化、压缩、文件导入等特性

style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。

eslint-loader：通过 ESLint 检查 JavaScript 代码












