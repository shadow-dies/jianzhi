## Cookie

cookie是存放在浏览器中的，浏览器的安装目录中存在一个文件夹，用来存放各个域（网站）的cookie信息，当浏览器访问某个域时，浏览器就会将
该域下面的cookie自动放入request header中。

所以存放在cookie的数据最合适的是身份认证信息，其他信息都不合适。

我们在控制台打印document.cookie就可以拿到当前域下面的全部可以访问的cookie了(也就是非httpOnly的cookie),注意观察的cookie,是由key=value的形式组成，并且在每一个key,value之间使用分号和空格隔开。

只要HttpOnly打钩的js是无法获取和操作的，这种Cookie是只能由服务端和浏览器来操作，通常这种Cookie是用来存储一些用户身份信息或者安全相关的凭证的

可以使用下面的代码将Cookie储存到一个对象中

```js
function deal(){ var cookie = document.cookie;
var arr = cookie.split('; ');//注意是 分号空格
var obj = {};
    arr.forEach(function(item){
       var itemArr = item.split('=');
       obj[itemArr[0]] = itemArr[1];
})
    return obj;
}
```

cookie具有很多字段

* Name：cookie的名字(键)

* Value：cookie存放的值
  
* Expires：指cookie过期的时间（该时间为世界时间 UTC时间）也称为格林威治时间
  
* Max-Age: 指cookie最大的存活有效期（单位：秒）
    >Expires与max-age属性同时存在时max-age的优先级会更高
  
* Domain: 指的是cookie当前的域
    >值得注意的是，如 .baidu.com 代表的是baidu.com这个域及其子域， 而baidu.com只代表baidu.com这个域。在设置Cookie时如果没有设置Domain属性那么这个Cookie只能作用于当前域
  
* Path:指cookie当前的路径
  
* Size: 指cookie存放的大小
  
* httpOnly
  >只要HttpOnly打钩的js是无法获取和操作的，这种Cookie是只能由服务端和浏览器来操作，通常这种Cookie是用来存储一些用户身份信息或者安全相关的凭证的。
  
* Secure: 指cooke的安全属性
    >secure 这个属性用来告诉浏览器这个Cookie只能用https协议传输，如果服务端的响应中包含有secure属性的Cookie，但是当前的协议是http的，那么浏览器会直接忽略这个Cookie

## 缓存

localStorage

sessionStorage
>sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。

http缓存
>Web 缓存是可以自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这 个文档。

HTTP缓存分为强制缓存和协商缓存

强制缓存
>浏览器的目标资源如果在缓存中命中，则强制从缓存中读取，不向服务器发送请求。

基于Cache-control实现的强缓存

Cache-control的使用方法页很简单，只要在资源的响应头上写上需要缓存多久就好了，单位是秒。比如↓
```js
//往响应头中写入需要缓存的时间
res.writeHead(200,{
    'Cache-Control':'max-age=10'
});
```

协商缓存


**基于last-modified的协商缓存**

基于last-modified的协商缓存实现方式是:

  * 首先需要在服务器端读出文件修改时间，

  * 将读出来的修改时间赋给响应头的last-modified字段。

  * 最后设置Cache-control:no-cache

```js
const {mtime} = fs.statSync('filename');//读取文件修改时间
res.setHeader('last-modified', mtime.toUTCString())//设置文件最后修改时间
res.setHeader('Cach-control', 'no-cache');

```

当客户端读取到last-modified的时候，会在下次的请求标头中携带一个字段:If-Modified-Since。If-Modified-Since的值就是服务器给他设置的最后修改时间。

那么之后每次对该资源的请求，都会带上If-Modified-Since这个字段，而务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源。

但这个方法的问题在于文件有一点轻微的改变（如文件名改变）都会使缓存失效。

当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会 返回新的文件。

为了解决上述的这两个问题。从http1.1开始新增了一个头信息，ETag(Entity 实体标签)

**基础ETag的协商缓存**

ETag就是将原先协商缓存的比较时间戳的形式修改成了比较文件指纹。
>文件指纹:根据文件内容计算出的唯一哈希值。文件内容一旦改变则指纹改变。

流程：

1.第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的etag字段中跟资源一起返回给客户端。

2.第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的ETag也就是文件指纹。并赋给请求头的if-None-Match字段，让上一次的文件指纹跟随请求一起回到服务端。

3.服务端拿到请求头中的is-None-Match字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并return。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的ETag中并返回给客户端

## ES6
新增了块级作用域（let，const）

ES6新增了模块化（import / export）

ES6新增了Set和Map数据结构。

数组新增了一些API，如isArray / from / of 方法；数组实例新增了 entries()，keys() 和 values() 等方法。

## import和require的区别

* import是es6规范语法，require是AMD规范引入方式
* import是编译时加载，只能放在文件头，require是运行时加载，require能放在文件的任意一个地方。import的性能更好。
* import为浅拷贝，即引入的对象被修改时，源对象也会被修改。require为深拷贝，





## ts相比于js的区别

ts相比于js更加的稳定

在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。
接口是对象的状态(属性)和行为(方法)的抽象(描述)

而TypeScript 是JavaScript 的超集（ts是微软开发的开源编程语言），即包含JavaScript 的所有元素，能运行JavaScript 的代码，并扩展了JavaScript 的语法。（ts包含了js的库和函数，ts上可以写任何的js，调用任何的js库，可以在ts中使用原生js语法）。

区别：

1、TypeScript 引入了 JavaScript 中没有的“类”概念

2、TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。

3、js没有重载概念，ts有可以重载

4、ts增加了接口interface、泛型、类、类的多态、继承等

5、ts对比js基础类型上，增加了 void/never/any/元组/枚举/以及一些高级类型

js有的类型：boolean类型、number类型、string类型、array类型、undefined、null

ts新增的类型：tuple类型（元组类型）、enum类型（枚举类型）、any类型（任意类型）

void类型（没有任何类型）表示定义方法没有返回值
never类型：是其他类型（包括null和undefined）的子类型，代表从不会出现的值这意味着声明never变量只能被never类型所赋值

js变量是没有类型的，即age=18，age可以是任何类型的，可以继续给age赋值为age=”aaa”
Ts有明确的类型(即：变量名:number(数值类型))  eg：let age: number = 18

## setstate具体流程

1.调用setState不会立即更新

2.所有组件使用的是同一套更新机制，当所有组件didmount后，父组件didmount，然后执行更新

3.更新时会把每个组件的更新合并，每个组件只会触发一次更新的生命周期。

## react生命周期
组件的生命周期可分成三个状态：

* Mounting(挂载)：已插入真实 DOM
* Updating(更新)：正在被重新渲染
* Unmounting(卸载)：已移出真实 DOM

当组件的 props 或 state 发生变化时会触发更新。

## ctx代表着什么
ctx是context的缩写中文一般叫成上下文，这个在所有语言里都有的名词，可以理解为上(request)下(response)沟通的环境，所以koa中把他们两都封装进了ctx对象，koa官方文档里的解释是为了调用方便，ctx.req=ctx.request,ctx.res=ctx.response，类似linux系统中的软连接？最终执行还是request和response对象

body是http协议中的响应体，header是指响应头

## koa-session的运作原理
>Session，又称为“会话控制”，存储特定用户会话所需的属性及配置信息。存于服务器，在整个用户会话中一直存在。

初始化 koa-session 时，会要求传入一个app实例。

实际上，正是在初始化的时候，往 app.context 上挂载了session对象，并且 session 对象是由 lib/context.js 实例化而来，所以我们使用的 ctx.session 就是 koa-session 自己构造的一个类。

那么 session 在什么时候被创建呢？回到上面提到的拦截器 extendContext ，它会在接到http请求的时候，从 ContextSession类 实例化出 session 对象。
>也就是说，session 是中间件自己创建并管理的，并非由web服务器产生。

session 并不是服务器原生支持，而是由web服务程序自己创建管理。

存放在哪里呢？不一定要在服务器，可以像 koa-session 一样骚气地放在 cookie 中！实际就是默认把数据 json ，塞进了 cookie ，即 cookie 来存储加密后的 session 信息。

koa-session 的做法说明了，session 仅仅是一个对象信息，可以存到 cookie ，也可以存到任何地方（如内存，数据库）。存到哪，可以开发者自己决定，只要实现一个 store 对象，提供 set，get 方法即可。

不得不说，store 的插件式设计非常优秀。koa-session 不必关心数据具体是如何存储的，只要插件提供它所需的存取方法。

这种插件式架构，反转了模块间的依赖关系，使得 koa-session 非常容易扩展。

koa的cookie本身带了安全机制，也就是config里的signed设为true的时候，会自动给cookie加上一个sha256的签名，类似koa:sess.sig=pjadZtLAVtiO6-Haw1vnZZWrRm8，从而防止cookie被篡改。

## https的安全性从何而来

客户端请求后服务端会提供SSL证书，然后服务端和客户端的信息传输会通过对称密钥进行加密。

## 登录功能实现

cookie

token
>Token是服务端生成的一串字符串，当作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token并将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

## react类组件和函数组件的区别

**一、语法不同、设计思想不同**

函数式组件是函数式编程思想，而类组件是面向对象编程思想。面向对象编程将属性和方法封装起来，屏蔽很多细节，不利于测试。

**二、生命周期、状态变量**

类式组件：使用state对象定义状态变量，有诸如componmentDidMount、shouldComponentUpdate等生命周期钩子函数；

函数式组件：没有this,使用一系列的内置hooks实现对应的功能，比如使用useState创建状态变量，使用useEffect实现类似于componmentDidMount、shouldComponentUpdate等生命周期钩子函数的功能。

**三、复用性**

类式组件：使用hoc（高阶组件）、render propss实现组件的逻辑复用、拓展组件的功能。

函数式组件：使用自定义hooks实现组件的逻辑复用。

**四、优缺点**

函数式组件：

优点：

  * 相对于类式组件，一般情况而言，代码量更少，代码更简洁，可读性更强；
更易于拆分组件和测试；
缺点：
  * 在业务逻辑巨复杂，状态依赖关系错乱的情况下，使用useEffect、useMemo等hooks，对其依赖项数组的思考为开发者带来了更大的心智负担；
  * 不具备处理错误边界等业务情况的hooks；

类式组件：

优点：
  * 功能完备，具有componentDidsCatch、getDerivedStateFromError等钩子函数处理边界错误；
 缺点：
  * 在复用性上，hoc组件等会出现诸如嵌套地狱、重名props被覆盖、难以拆分和测试等问题；

---

## redux实现子组件之间传递数据

Redux

1.redux 是一个独立专门用于做状态管理的 JS 库(不是 react 插件库)

2.它可以用在 react, angular, vue 等项目中, 但基本与 react 配合使用

3.作用: 集中式管理 react 应用中多个组件共享的状态

核心概念

state action reducer Store

当使用普通对象来描述应用的 state 时。这个对象就像 “Model”，区别是它并没有 setter（修改器方法）。

例如，todo 应用的 state 可能长这样：
```js
{
  todos: [{
    text: 'Eat food',
    completed: true
  }, {
    text: 'Exercise',
    completed: false
  }],
  visibilityFilter: 'SHOW_COMPLETED'
}
```
要想更新 state 中的数据，你需要发起一个 action。Action 就是一个普通 JavaScript 对象

下面是一些 action 的示例：
```
{ type: 'ADD_TODO', text: 'Go to swimming pool' }
{ type: 'TOGGLE_TODO', index: 1 }
{ type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }
```
为了把 action 和 state 串起来，开发一些函数，这就是 reducer。reducer 只是一个接收 state 和 action，并返回新的 state 的函数。 
```js
(previousState, action) => newState
```

示例：

```js
function visibilityFilter(state = 'SHOW_ALL', action) {
  if (action.type === 'SET_VISIBILITY_FILTER') {
    return action.filter;
  } else {
    return state;
  }
}

function todos(state = [], action) {
  switch (action.type) {
  case 'ADD_TODO':
    return state.concat([{ text: action.text, completed: false }]);
  case 'TOGGLE_TODO':
    return state.map((todo, index) =>
      action.index === index ?
        { text: todo.text, completed: !todo.completed } :
        todo
   )
  default:
    return state;
  }
}
```

再开发一个 reducer 调用这两个 reducer，进而来管理整个应用的 state：
```js
function todoApp(state = {}, action) {
  return {
    todos: todos(state.todos, action),
    visibilityFilter: visibilityFilter(state.visibilityFilter, action)
  };
}
```

注意
  * 不要修改 state。
  * 在 default 情况下返回旧的 state。

Store
>Store 就是把它们联系到一起的对象。

Store 有以下职责：
  * 维持应用的 state；
  * 提供 getState() 方法获取 state；
  * 提供 dispatch(action) 方法更新 state；
  * 通过 subscribe(listener) 注册监听器;
  * 通过 subscribe(listener) 返回的函数注销监听器。

Redux 应用只有一个单一的 store,当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。

使用 combineReducers() 将多个 reducer 合并成为一个。现在我们将其导入，并传递 createStore()。
```js
import { createStore } from 'redux'
import todoApp from './reducers'
let store = createStore(todoApp)
```
createStore() 的第二个参数是可选的, 用于设置 state 初始状态。

**redux的三大原则**

  * 单一数据源
    >整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。

  * State 是只读的
    >唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。

  * 使用纯函数来执行修改
    >为了描述 action 如何改变 state tree ，你需要编写 reducers。

**数据流**
>严格的单向数据流是 Redux 架构的设计核心。

Redux 应用中数据的生命周期遵循下面 4 个步骤：

1.调用 store.dispatch(action)。

2.Redux store 调用传入的 reducer 函数。

3.根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。

4.Redux store 保存了根 reducer 返回的完整 state 树。

现在，可以应用新的 state 来更新 UI。如果你使用了 React Redux 这类的绑定库，这时就应该调用 component.setState(newState) 来更新。

**与React结合使用**

现在来创建一些容器组件把这些展示组件和 Redux 关联起来。技术上讲，容器组件就是使用 store.subscribe() 从 Redux state 树中读取部分数据，并通过 props 来把这些数据提供给要渲染的组件。你可以手工来开发容器组件，但建议使用 React Redux 库的 connect() 方法来生成，这个方法做了性能优化来避免很多不必要的重复渲染。

connect
>connect() 函数将 React 组件连接到 React store。它向连接的组件提供其需要从 store 中获取的数据片段，以及可以用来向 store dispatch actions 的功能。connect是高阶组件，接受两个方法，返回的函数接收参数是组件，从而返回一个新的组件。

```js
connect([mapStateToProps], [mapDispatchToProps])(component)
```
connect的作用

connect负责连接React和Redux

connect作用是让你把组件和store连接起来，产生一个新的组件（connect 是高阶组件）

* 获取state
  >connect 通过 context获取 Provider 中的 store，通过 store.getState() 获取整个store tree 上所有state

* 包装原组件
  >将state和action通过props的方式传入到原组件内部 wrapWithConnect 返回—个 ReactComponent 对象 Connect，Connect重新 render 外部传入的原组件 WrappedComponent ，并把 connect 中传入的 mapStateToProps，mapDispatchToProps与组件上原有的 props 合并后，通过属性的方式传给 WrappedComponent

* 监听store tree变化
  >connect缓存了store tree中state的状态，通过当前state状态 和变更前 state 状态进行比较，从而确定是否调用 this.setState()方法触发 Connect 及其子组件的重新渲染

异步action
>对象（Object）形式叫做同步action,函数（function）形式称为异步action

安装中间件 配置在store中
```bash
yarn add redux-thunk
```

```js
import applyMiddleware from "redux";
import thunk from "redux-thunk"
const store = createStore(countRedux, applyMiddleware(thunk))
```
```js
add4=() => {
       const {value}=this.select
       store.dispatch(ceactAsyncAdd1Action(value*1,500))

    }
```

在action.js中

返回一个函数
```js
export const ceactAsyncAdd1Action=(data,time)=>{
  // 返回函数异步action
   return () => {
     setTimeout(() => {
      store.dispatch(ceactAdd1Action(data))
     },time)
   }
}
```



## 性能优化


**webpack优化**

如何提⾼webpack的打包速度? 

（1）优化 Loader

对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，这是可以优化的。

优化 Loader 的文件搜索范围
```js
module.exports = {
  module: {
    rules: [
      {
        // js 文件才使用 babel
        test: /\.js$/,
        loader: 'babel-loader',
        // 只在 src 文件夹下查找
        include: [resolve('src')],
        // 不会去查找的路径
        exclude: /node_modules/
      }
    ]
  }
}
```
对于 Babel 来说，希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。

当然这样做还不够，还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间
```js
loader: 'babel-loader?cacheDirectory=true'
```

HappyPack

受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。

HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了
```js
module: {
  loaders: [
    {
      test: /\.js$/,
      include: [resolve('src')],
      exclude: /node_modules/,
      // id 后面的内容对应下面
      loader: 'happypack/loader?id=happybabel'
    }
  ]
},
plugins: [
  new HappyPack({
    id: 'happybabel',
    loaders: ['babel-loader?cacheDirectory'],
    // 开启 4 个线程
    threads: 4
  })
]
```


## webpack构建流程

## promise.all

Promise.all可以将多个Promise实例包装成一个Promise实例。

Promise.all方法可以接受一个数组作为参数，数组中的每一项都是一个Promise的对象实例（如果不是，就会先调用Promise.reslove方法，将参数转化为Promise对象实例，再进行下一步的处理）。Promise.all方法的参数不一定是数组，但是必须具有Iterator接口。

只有数组里每个Promise的状态都编程了Fulfilled，Promise.all的状态才会变成Fulefilled，然后将每一个状态发返回的值，组装程一个数组返回给后面的回调函数。

只要数组里面有一个Promise的状态是Rejected，Promise.all的状态就会变成Rejected。这个时候第一个被Rejected的实例的结果会传递给后面你的回调。

如果作为参数的Promise实例自身定义了catch方法，那么他被Rejected时并不会被Promise.all的catch的方法给接受。

Promise.all中的执行的顺序其实应该是并行的

手动实现promise.all

```js
Promise.all = function (promise) {
  return new Promise((resolve, reject) => {
      let index = 0
      let result = []
      if (promise.length === 0) {
          resolve(result)
      } else {
          function processValue(i, data) {
              result[i] = data
              if (++index === promise.length) {
                  resolve(result)
              }
          }
          for (let i = 0; i < promise.length; i++) {
              Promise.resolve(promise[i]).then((data) => {
                  processValue(i, data)
              }, (err) => {
                  reject(err)
                  return
              })
          }
      }
  })
}
```

并发限制

如果我们希望将promise.all中的处理改为串行的，我们可以这样写
```js
promise.asyncAll = function(promises) {
  return new Promise((resolve, reject) => {
    let index = 0;
    let result = [];
    if(promises.length === 0) return resolve(result);
    else {
      function runPromise() {
        if(index === promises.length) return resolve(result);
        else {
          Promise.resolve(promises[index]).then(data => {
            result[index] = data;
            index++;
            runPromise();
          }, err => {
            reject(err);
          })
        }
      }
      runPromise();
    }
  })
}
```

如果我们想实现五个并行，其余串行、

```js
Promise.asyncStep = function (promises) {
  return new Promise((resolve, reject) => {
    let index = 0
    let stepCount = 5
    let result = []
    let count = promise.length
    if (promise.length === 0) {
        resolve(result)
    } else {
      function runPromise () {
        if (index === promise.length) {
          resolve(result);
        } else {
          stepCount = Math.min(count, stepCount)
          for (let i = 0; i < stepCount; i++) {
            --count;
            Promise.resolve(promise[index]).then(data => {
              result[index] = data;
              ++index;
            }, err => {
              reject(err)
            });
          }
          runPromise();
        }
      }
      runPromise()
    }
  })
}
```

## async promise settimeout 调用顺序

宏任务
>同步任务

微任务
>异步任务，如promise.then

执行的顺序：当前轮宏任务 -> 当前轮微任务 -> 下一轮宏任务 -> 下一轮微任务
```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
async1();
console.log('start')

//结果如下
/*
async1 start
async2
start
async1 end
*/
```
1 首先执行函数中的同步代码async1 start，之后遇到了await，它会阻塞async1后面代码的执行，因此会先去执行async2中的同步代码async2，然后跳出async1；

2 跳出async1函数后，执行同步代码start；

3 在一轮宏任务全部执行完之后，再来执行await后面的内容async1 end。

这里可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。

## React17

## 分布式计算

## 洋葱模型

## 设计模式



